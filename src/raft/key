type AppendEntriesArgs struct {
	Term		int
	LeaderId	int
}
type AppendEntriesReply struct {
	Term	int
	Success	bool
}
func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) {
	rf.heartBeat = true

	if args.Term < rf.currentTerm {
		reply.Success = false
	} else {
		reply.Success = true
		rf.currentTerm = args.Term
	}
	reply.Term = rf.currentTerm
}


func (rf *Raft) return2Follower(vot int, cur int) {
	rf.votedFor = vot
	rf.currentTerm = cur
	rf.state = 2
	if !timer.Stop() && len(timer.C)>0 {
		<- timer.C
	}
	rf.timer.Reset((150+rand.Int31() % 151) * time.Millisecond)
}

type RequestVoteArgs struct {
	// Your data here (2A, 2B).
	Term			int
	CandidateId		int
}


type RequestVoteReply struct {
	// Your data here (2A).
	Term			int
	VoteGranted		bool
}
func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) {
	// Your code here (2A, 2B).
	if rf.state == 0 || args.Term < rf.currentTerm {
		reply.VoteGranted = false
	} else {
		if rf.votedFor < 0 {
			reply.VoteGranted = true
			rf.votedFor = args.CandidateId
			rf.currentTerm = args.Term
		} else {
			reply.VoteGranted = false
		}
	}
	reply.Term = rf.currentTerm
}



type Raft struct {
	peers     []*labrpc.ClientEnd // RPC end points of all peers
	me        int                 // this peer's index into peers[]

	currentTerm	int
	votedFor	int

	state 		int 	// 0, leader; 1, candidate; 2, follower

	heartBeat	bool
}